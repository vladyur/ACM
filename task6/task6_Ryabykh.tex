\documentclass[a4paper,12pt]{article}

\input{AMV_Preamble.tex}

\begin{document}
	
	\thispagestyle{firstpage}
	
	\begin{center}
		\textbf{\Large{Алгоритмы и модели вычислений. \\ Домашнее задание № 6}}
	\end{center}
	
\begin{tasknum}{1}
	Теорема Рейнгольда утверждает, что язык $UPATH = \{(G, s, t) |$ в неориентированном графе $G$ есть неориентированный путь из $s$ в $t\}$ лежит в $\mathcal{L}$. Опираясь на этот факт, докажите, что следующие языки лежат в $\mathcal{L}$:
	
	\begin{enumerate}
		\item $EVENCONN = \{G |$ неориентированный граф $G$ имеет чётное число компонент связности$\}$;
		\item $EDGEUCYCLE = \{(G, e) |$ в неориентированном графе $G$ существует цикл, содержащий ребро $e\}$;
		\item $XOR2SAT = \{\phi$ | $\phi$ — конъюнкция выражений вида $x_i \oplus x_j$, для которой есть выполняющий набор$\}$.
	\end{enumerate}
\end{tasknum}

\begin{solution}
	\begin{enumerate}
		\item Для определения, лежит ли граф $G$ в нашем языке $EVENCONN$, будем хранить в памяти всего 2 счётчика: счётчик текущей вершины $num$ и бит, отвечающий за чётность числа компонент $IsEven$ (изначально равен 1). Мы нумеруем все вершины графа и действуем следующим образом, пока $num$ не пройдёт все вершины нашего графа.
		
		\begin{itemize}
		\item Если из 1 вершины есть путь в вершину $num$ (что мы проверяем за логарифмическую память по теореме Рейнгольда), то мы увеличиваем счётчик $num$: $num = num + 1$.
		
		\item Если же из 1 вершины нет пути в вершину $num$ (что мы проверяем за логарифмическую память по теореме Рейнгольда), то мы проверяем наличие пути из $num$ в какую-нибудь из вершин с меньшим номером. 
		
		\begin{itemize}
			\item Если такая есть, то мы увеличиваем счётчик $num$: $num = num + 1$.
			\item Если такой нет, то меняем значение $IsEven$ на противоположное и увеличиваем счётчик $num$: $num = num + 1$.
		\end{itemize}		
	\end{itemize}

	Заметим, что в таком алгоритме бит $IsEven$ меняет своё значение, только если текущая вершина не связана ребром ни с одной из ранее рассмотренных, то есть лежит в новой компоненте связности относительно найденных ранее алгоритмом. Таким образом, после окончания алгоритма $G \in EVENCOMM \LRa IsEven = 1 \Ra EVENCOMM \in \mathcal{L}$.

	\item Для того, чтобы проверить принадлежность $(G, e)$ к $EDGEUCYCLE$, где $G = (V, E)$ рассмотрим граф $\tilde{G} = (V, \tilde{E})$, где $\tilde{E}$ содержит все рёбра $E$, кроме $e$. Пусть $e = (u, v)$, тогда, очевидно, $(G, e) \in EDGEUCYCLE \LRa (\tilde{G}, u, v) \in UPATH$, что мы проверяем за логарифмическую память по теореме Рейнгольда, так что $EDGEUCYCLE \in \mathcal{L}$.
	
	\item Сведём $XOR2SAT$ к языку $BIPARTITE$, который лежит в $\mathcal{L}$, доказательство этого есть в конспекте. По формуле $\phi$ будем строить граф $G = (V, E)$ следующим образом: $V = \{x_i$ | переменная $x_i$ лежит в формуле $\phi\}$, а вершины $x_i$ и $x_j$ будем соединять ребром тогда и только тогда, когда в формуле $\phi$ есть конъюнкт вида $x_i \oplus x_j$. Таким образом мы можем за логарифм от длины входа построить наш граф $G$: перебором всех переменных заполняем матрицу смежности.
	
	Докажем, что $\phi \in XOR2SAT \LRa G \in BIPARTITE$:
	\begin{itemize}
		\item $\Ra$: $\phi \in XOR2SAT \Ra \phi$ выполнима, то есть существует такой набор переменных, что в каждом конъюнкте вида $x_i \oplus x_j$ справедливо, что $x_i$ и $x_j$ принимают различные значения, так что если в $\phi$ есть конъюнкты $x_i \oplus x_j$ и $x_i \oplus x_k$, то $x_j = x_k$, а следовательно $x_j \oplus x_k = 0$ и такого конъюнкта в $\phi$ нет, то есть в нашем графе $G$ $x_j$ и $x_k$ ребром соединены не будут, а следовательно в нашем графе нет треугольников, а циклов большей нечётной длины в графе быть не может в принципе, так что граф двудолен.
		
		\item $\La$: $G$ двудольный $\Ra$ примем все переменные одной доли равными 0, другой доли~---~равными 1, тогда в каждом конъюнкте вида $x_i \oplus x_j$ справедливо, что $x_i$ и $x_j$ принимают различные значения, так что $\phi$ выполняется на этом наборе.
	\end{itemize}
	
	Таким образом мы доказали, что $XOR2SAT \leq_L BIPARTITE \wedge BIPARTITE \in \mathcal{L} \Ra XOR2SAT \in \mathcal{L}$, что и требовалось.
	
	\end{enumerate}
\end{solution}

\begin{tasknum}{2}
	Докажите, что $2SAT \in \mathcal{NL}$.
\end{tasknum}

\begin{solution}
	Во-первых вспомним, что $x_i \vee x_j \LRa \ol{x_i} \ra x_j$. А во-вторых, что $\mathcal{NL} = co-\mathcal{NL}$ по Immerman–Szelepcsényi theorem. Тогда мы можем каждый из наших дизъюнктов переписать в виде импликации. Таким образом, в качестве сертификата для нашей машины Тьюринга возьмём цепь импликаций вида $x_i \ra \ldots \ra \ol{x_i} \ra \ldots \ra x_i$, наша МТ будет идти по цепочке и смотреть, есть ли каждая импликация в нашей исходной формуле. Докажем, что если такая цепь есть в нашей исходной формуле, то она невыполнима: от противного: пусть $x_i = 1$, тогда все последующие литералы в импликации также должны быть равными 1 (так как исходная формула равняется 1 на данном наборе переменных), но тогда получим импликацию $1 \ra \ol{x_i} = 1 \ra 0 = 0$~---~противоречие, если же $x_i = 0$, то аналогично рассматривая вторую половину цепочки получаем импликацию $1 \ra x_i = 1 \ra 0 = 0$~---~противоречие.
	
	Таким образом $2SAT \in co-\mathcal{NL} \Ra 2SAT \in \mathcal{NL}$.
\end{solution}

\begin{tasknum}{3}
	Докажите, $\mathcal{NL}$-полноту языка $2SAT$.
\end{tasknum}

\begin{solution}
	Сведём к $2SAT$ $co-\mathcal{NL}$-полный язык $\ol{PATH}$. Так как $co-\mathcal{NL} = \mathcal{NL}$, то язык $\ol{PATH}$ также является $\mathcal{NL}$-полным языком. Построим КНФ следующим образом: (имеем тройку ($G, s, t$), как элемент $\ol{PATH}$). Заведём по одной переменной для каждой из вершин, внесём в нашу формулу дизъюнкты $s$ и $\ol{t}$. А для $(x, y) \in E$ внесём в формулу дизъюнкт $\ol{x} \vee y$. Докажем теперь, что пути из $s$ в $t$ нет $\LRa$ КНФ выполнима.
	
	\begin{itemize}
		\item $\Ra$: возьмём все вершины, которые достигаются из вершины $s$ и пометим соответствующие им переменные, как истинные, а все остальные, как ложные. $s = 1, t = 0$. Тогда в нашем графе нет рёбер, которые идут от вершины с соответствующей ей переменной, равной $1$ к вершине с соответствующей ей переменной, равной $0$. От противного: если есть ребро $(u,v$), где $u = 1, v=0$, то существует путь $s \ra \ldots \ra u \ra v$, то есть $v$ достижима из $s$. Тогда все дизъюнкты вида $\ol{x} \vee y$, равно как $s$ и $\ol{t}$ обращаются в 1, следовательно КНФ обращается в 1 на этом наборе $\Ra$ выполнима. 
		
		\item $\La$: КНФ выполнима $\Ra$ существует набор, на котором формула обращается в 1, возьмём его. Допустим, что в КНФ был дизъюнкт $\ol{x} \vee y$. Он обращается в 1, так что не может быть такого, чтобы $x$ был равен 1, а $y$ обращался в 0. Таким образом, можно построить достижимые из $s$ вершины равно как в предыдущем пункте: все вершины, достижимые из $s$ обращаются в 1 (так как если $(s, u) \in E$, то есть дизъюнкт $\ol{s} \vee u = 1$, где $s = 0 \Ra u = 1$. Но так как КНФ выполнима, то $\ol{t} = 1$, то есть $t=0$~---~недостижимая из $s$ вершина
	\end{itemize}
	
	Таким образом мы построили сводимость $\ol{PATH} \leq_L 2SAT$, следовательно $2SAT$ также является $\mathcal{NL}$-полным языком.
	
\end{solution}

\begin{tasknum}{4}
	Докажите, что класс $P \diagup poly$ не изменится, если в качестве размера вместо числа
	вершин брать число рёбер.
\end{tasknum}

\begin{solution}
	$P \diagup poly$~---~класс языков, распознающихся семейством схем полиномиального размера (где размер есть число вершин в минимального схеме). Докажем, что если брать тут в качестве размера число рёбер, то класс не изменится:
	
	\begin{itemize}
		\item возьмём схему, распознающую язык и имеющую полиномиальный размер в смысле вершин: пусть этот размер есть $f(n) = poly(n)$. Так как всего в этой схеме рёбер $\le f(n) \cdot f(n) = poly(n)$, то язык также распознаётся схемой с полиномиальным размером в смысле рёбер.
		
		\item возьмём схему, распознающую язык и имеющую полиномиальный размер в смысле рёбер: пусть этот размер есть $f(n) = poly(n)$. Так в нашей схеме $\le n$ изолированных вершин (их не может быть больше, чем входных переменных), а остальных вершин не может быть больше общего числа рёбер, то всего вершин $\le n + f(n) = poly(n)$. Таким образом этот язык также распознаётся схемой с полиномиальным размером в смысле вершин.
	\end{itemize}

	Таким образом мы доказали, что язык распознаётся семейством схем полиномиального размера в смысле вершин $\LRa$ язык распознаётся семейством схем полиномиального размера в смысле рёбер. То есть эти классы действительно совпадают.
\end{solution}

\newpage

\begin{tasknum}{5}
	Докажите, что класс $P \diagup poly$ не зависит от того, какая входящая степень разрешена
	для вершин типов $\wedge$ и $\vee$.
\end{tasknum}

\begin{solution}
	Пусть теперь разрешённая входящая степень есть $N$, обозначим получившийся класс как $P \diagup poly - N$. Докажем, что на самом деле $P \diagup poly = P \diagup poly - N$:
	
	\begin{itemize}
		\item $P \diagup poly \subseteq P \diagup poly - N$: верно, так как, очевидно, мы можем не обращать внимание на увеличение входящей степени и продолжать пользоваться схемами, где в каждую вершину вида $\wedge$ и $\vee$ входит не больше двух рёбер.
		
		\item $P \diagup poly - N \subseteq P \diagup poly$: развернём каждую из вершин вида $\wedge$ и $\vee$ <<слева-направо>>, как показано ниже:
		
		Изначально имеем следующую схему:
		
		\begin{center}
			\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2.8cm]
			\node[state]                (A)                  {$x_1$};
			\node[state]              (B) [right of=A]     {$x_2$};
			\node[state]                        (C) [right of=B]     {$x_3$};
			\node[state]                        (E) [right of=C]     {$x_4$};
			\node[state]                        (F) [right of=E]     {$x_5$};
			\node[state]                        (D) [below of=C]   {$\vee$};
			
			\path
			(A) edge node [swap] {} (D)
			(B) edge  node {} (D)
			(E) edge  node {} (D)
			(F) edge  node {} (D)
			(C) edge             node {} (D);
			\end{tikzpicture}
		\end{center}
		
		Разворачиваем <<слева-направо>>:
		
		\begin{center}
			\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2.8cm]
			\node[state]                (A)                  {$x_1$};
			\node[state]              (B) [right of=A]     {$x_2$};
			\node[state]                        (C) [right of=B]     {$x_3$};
			\node[state]                        (F) [right of=C]     {$x_4$};
			\node[state]                        (H) [right of=E]     {$x_5$};
			\node[state]                        (D) [below right of=A]   {$\vee$};
			\node[state]                        (E) [below right of=D]   {$\vee$};
			\node[state]                        (G) [below right of=E]   {$\vee$};
			\node[state]                        (K) [below right of=G]   {$\vee$};
			
			\path
			(A) edge node [swap] {} (D)
			(B) edge  node {} (D)
			(D) edge  node {} (E)
			(F) edge  node {} (G)
			(E) edge  node {} (G)
			(H) edge  node {} (K)
			(G) edge  node {} (K)
			(C) edge             node {} (E);
			\end{tikzpicture}
		\end{center}
		
		Таким образом можно видеть, что если у нас была схема на $m$ вершинах, причём $m = poly(n)$, то после такого эквивалентного преобразования мы получаем схему с $\le N \cdot poly(m) \le m \cdot poly(poly(n)) = poly(n)$ вершин. Таким образом размер остаётся полиномиальным, то есть $P \diagup poly - N \subseteq P \diagup poly$, чего нам и не хватало для доказательства того, что $P \diagup poly = P \diagup poly - N$.
		
	\end{itemize}
\end{solution}

\end{document}